---
  - hosts: localhost
    name: deploy titan-standalone mini mode
    gather_facts: false
    strategy: parallel
    vars_files: 
      - var_file.yml
    module_defaults:
      kubernetes.core.k8s_info:
        validate_certs: no
        namespace: "{{ namespace }}"
      kubernetes.core.k8s:
        validate_certs: no
        namespace: "{{ namespace }}"
      kubernetes.core.k8s_exec:
        validate_certs: no
        namespace: "{{ namespace }}"

    pre_tasks:
      - name: include pre_titan_env
        include_tasks: pre_titan_env.yml

      - name: include common pre_tasks
        include_tasks: pre_tasks.yml

    # 并发数量由ansible.cfg中 strategy.parallel 部分下的 semaphore_num 配置决定
    # 默认2个，不建议超过3个。超过3个对etcd的压力太大，可能会出现莫名其妙退出的问题
    tasks:
      # localpv 必须最先安装
      - name: install localpv
        include_role:
          name: "localpv"
          tasks_from: mini.yml
        when: '"localpv" in install_roles'

      # mysql安装时对机器性能压力较大，不并发执行
      - name: install mysql
        include_role:
          name: "mysql"
          tasks_from: mini.yml
        when: '"mysql" in install_roles'

      - name: install mongo
        include_role:
          name: "mongo"
          tasks_from: mini.yml
        vars:
          ansible_parallel: "mongo"
        when: '"mongo" in install_roles'

      - name: install mongo-ms-srv
        include_role:
          name: "mongo-ms-srv"
          tasks_from: mini.yml
        vars:
          ansible_parallel: "mongo-ms-srv"
        when: '"mongo-ms-srv" in install_roles'

      - name: install zookeeper_kafka
        include_role:
          name: "{{item}}"
          tasks_from: mini.yml
        vars:
          ansible_parallel: "zk_kafka"
        loop: '{{ ["zookeeper","kafka"] | intersect(install_roles) }}'
        when: '["zookeeper","kafka"] | intersect(install_roles) | length > 0 '

      - name: install rabbitmq
        include_role:
          name: "rabbitmq"
          tasks_from: mini.yml
        vars:
          ansible_parallel: "rabbitmq"
        when: '"rabbitmq" in install_roles'

      - name: install redisjava
        include_role:
          name: "redisjava"
          tasks_from: mini.yml
        vars:
          ansible_parallel: "redisjava"
        when: '"redisjava" in install_roles'

      - name: install redisphp
        include_role:
          name: "redisphp"
          tasks_from: mini.yml
        vars:
          ansible_parallel: "redisphp"
        when: '"redisphp" in install_roles'

      - name: install rediserl
        include_role:
          name: "rediserl"
          tasks_from: mini.yml
        vars:
          ansible_parallel: "rediserl"
        when: '"rediserl" in install_roles'

      # mini模式下dfs 使用 java节点的localpv
      - name: create localpvc for titan-dfs
        include_role:
          name: common
          tasks_from: local_pvc.yml
        vars:
          selectedNode: "{{ label_nodes[wisteria_nodelabel][0] }}"
          qtsa_perm: "2020-2020"
          qtsa_delete_data: "N"
          pvc_name: "titan-dfs"
          app: "titan-dfs"
          pvc_storage_capacity: "{{ dfs_storage_capacity }}"
          pv_path: ""

      - name: install titan-backup
        include_role:
          name: "titan-backup"
          tasks_from: mini.yml
        vars:
          ansible_parallel: "titan-backup"
        when: '"titan-backup" in install_roles'

      - name: wait child job, perhaps need about five minutes
        wait_parallel:
          parallel_names: ["mongo","rediserl","titan-backup"]
        when: base_roles | intersect(install_roles) | length > 0

      # 开始安装APP
      - name: install {{item}}
        include_role:
          name: "{{item}}"
        loop: "{{ app_roles | union(extra_roles)  | union(app_hive_roles) | intersect(install_roles) }}"

      # 当传入了 install_role 时 到这里结束
      - meta: end_play
        when: install_role is defined

      # 当存在 license 文件时，更新 license
      - name: get license file
        shell: sh -c "ls -t *-license-*.zip | head -1"
        register: license_file_result

      - set_fact:
          license_file: "{{license_file_result['stdout']}}"
      
      - name: get rules file
        shell: sh -c "ls -t *-rule-*.zip | head -1"
        register: rules_file_result

      - set_fact:
          rules_file: "{{rules_file_result['stdout']}}"

      # wait and update db
      - import_role:
          name: php
          tasks_from: wait_web_and_get.yml

      - import_role:
          name: php
          tasks_from: updatedb.yml

      # update license
      - name: execute license_update tasks
        include_role:
          name: common
          tasks_from: license_update.yml
        when: license_file != ""

      # 当存在license文件和规则文件时，进行 sync_rules ， 仅存在规则文件，不执行，sync_rules 依赖于license授权成功
      - include_role:
          name: php
          tasks_from: sync_rules.yml
        when: license_file != "" and rules_file != ""

      # 当存在license文件时, 进行 update_agent_config 操作， 依赖于license授权成功
      - name: execute update_agent_config tasks
        include_role:
          name: php
          tasks_from: update_agent_config.yml
        when: license_file != ""

    post_tasks:

      # 安装完成后就对配置做一次备份
      - name: backup old titan-config
        include_role:
          name: common
          tasks_from: backup_config.yml

