---
# tasks file for mysql
- set_fact:
    work_nodes: "{{ label_nodes[mysql_nodelabel] }}"

- name: Print result
  debug:
    msg: "{{ work_nodes }}"

- fail:
    msg: "have no available node for mysql"
  when: work_nodes|length < mysql_replicas


- name: create mysql headless service
  kubernetes.core.k8s:
    definition: "{{ lookup('template', 'mysql_hs.yml') | from_yaml }}"

- name: create mysql service
  kubernetes.core.k8s:
    definition: "{{ lookup('template', 'mysql_svc.yml') | from_yaml }}"

- name: create mysql configmap
  kubernetes.core.k8s:
    # mysql_configmap.yml 使用了dockerize, ansible的 jinja2 模板替换符和 golang template的一样了，这里将ansible的variable_start_string 进行修改
    definition: "{{ lookup('template', 'mysql_configmap.yml', variable_start_string='[%', variable_end_string='%]') | from_yaml }}"

# 解释一下，带预制规则则创建mysql_statefulset_install_withrules.yml， 关键点是podManagementPolicy: Parallel，在多台上同时拉取并解压预制规则
# 然后 创建不带预制规则的正常创建集群 statefulset
- block:
  - name: create mysql StatefulSet with rules Parallel
    kubernetes.core.k8s:
      definition: "{{ lookup('template', 'mysql_statefulset_install_withrules.yml' ) | from_yaml | titan_combine(common_patch) }}"
      apply: yes

  - name: wait mysql OK 
    kubernetes.core.k8s_info:
      kind: StatefulSet
      name: "mysql"
      namespace: "{{ namespace }}"
      wait: yes
      wait_sleep: 30
      wait_timeout: 150
    register: mysql_setobj
    until: mysql_setobj | statefulset_check
    retries: 8
    delay: 10

  - name: delete rules statefulset
    kubernetes.core.k8s:
      state: absent
      api_version: apps/v1
      kind: StatefulSet
      namespace: "{{ namespace }}"
      name: "mysql"
      wait: yes
      wait_sleep: 10
      wait_timeout: 150

  when: presetrule != 'N'

- name: create mysql normal running StatefulSet
  kubernetes.core.k8s:
    definition: "{{ lookup('template', 'mysql_statefulset.yml' ) | from_yaml | titan_combine(common_patch) }}"
    apply: yes

- name: wait mysql OK 
  kubernetes.core.k8s_info:
    kind: StatefulSet
    name: "mysql"
    namespace: "{{ namespace }}"
    wait: yes
    wait_sleep: 30
    wait_timeout: 150
  register: mysql_setobj
  until: mysql_setobj | statefulset_check(mysql_replicas)
  retries: 6
  delay: 10

#如果不是预置规则包，则启动一个临时的php，复制db下的sql文件并执行
- block:
    - name: cp db sql file
      command: bash -c 'kubectl -n {{namespace}} delete po dbsql-file; kubectl -n {{namespace}} run dbsql-file --image={{php_image}} -- tail -f /dev/null'
    
    - name: wait dbsql-file OK 
      command: kubectl -n {{namespace}} get po dbsql-file
      register: dbsqlpod_status
      until: '"Running" in dbsqlpod_status.stdout'
      retries: 6
      delay: 10

    - name: cp db sql file and delete dbsql-file
      command: bash -c 'rm -rf db && kubectl -n {{namespace}} cp dbsql-file:/data/app/www/titan-web/db db && kubectl -n {{namespace}} delete po dbsql-file'
    
    - name: cp db sql file and delete dbsql-file
      command: bash -c 'kubectl -n {{namespace}} cp db mysql-0:/tmp && rm -rf db'
    
    - name: cp db sql file and delete dbsql-file
      command: kubectl -n {{namespace}} exec -i mysql-0 -- bash -c 'mysql -uroot -p"{{mysql_passwd}}" < /tmp/db/{{sqlfile}}'
      vars:
        screen_only: true
      loop: ["titan-user.sql","titan.sql","titan-monitor.sql","titan-connect.sql","titan-back.sql","agent-monitor-db.sql"]
      loop_control:
        loop_var: sqlfile

  when: presetrule == 'N'

